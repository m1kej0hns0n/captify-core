{"version":3,"sources":["../src/lib/api.ts","../src/lib/react-compat.ts","../src/lib/auth.ts","../src/lib/utils.ts"],"sourcesContent":["\"use client\";\r\nimport type { Session } from \"next-auth\";\r\n\r\nexport interface CaptifyResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: string;\r\n}\r\n\r\nexport interface ApiRequest {\r\n  service: string;\r\n  operation: string;\r\n  app?: string;\r\n  table?: string;\r\n  identityPoolId?: string; // Optional Identity Pool ID to use for AWS credentials\r\n  forceRefresh?: boolean; // Force refresh of AWS credentials\r\n  data?: {\r\n    values?: Array<{ [field: string]: any }>;\r\n    fields?: string[];\r\n    index?: string;\r\n    limit?: number;\r\n    start?: any;\r\n    [key: string]: any; // Allow any additional data\r\n  };\r\n  useCache?: boolean; // Use native fetch caching\r\n}\r\n\r\nclass ApiClient {\r\n  private currentAppIdentityPoolId: string | undefined = undefined;\r\n  private currentAppSlug: string | undefined = undefined;\r\n  \r\n  // Set the current app's identity pool ID (called when app context changes)\r\n  setAppIdentityPool(poolId: string | undefined, appSlug?: string) {\r\n    // Only update if it's actually changing to prevent unnecessary logs\r\n    if (this.currentAppIdentityPoolId !== poolId || this.currentAppSlug !== appSlug) {\r\n      this.currentAppIdentityPoolId = poolId;\r\n      this.currentAppSlug = appSlug;\r\n      console.log(`[ApiClient] Identity pool set for app '${appSlug || 'unknown'}':`, poolId || 'none');\r\n    }\r\n  }\r\n  \r\n  // Get the current identity pool (for debugging)\r\n  getCurrentIdentityPool(): string | undefined {\r\n    return this.currentAppIdentityPoolId;\r\n  }\r\n  \r\n  async run<T = any>(request: ApiRequest): Promise<CaptifyResponse<T>> {\r\n    try {\r\n      // Use app from request, default to \"core\" if not specified\r\n      const app = request.app || \"core\";\r\n      const url = `/api/captify`;\r\n      \r\n      // If no identity pool is explicitly provided, use the current app's pool\r\n      const finalRequest = {\r\n        ...request,\r\n        identityPoolId: request.identityPoolId || this.currentAppIdentityPoolId\r\n      };\r\n      \r\n      // Debug logging\r\n      console.log('[ApiClient] Request details:', {\r\n        service: request.service,\r\n        operation: request.operation,\r\n        providedPoolId: request.identityPoolId,\r\n        currentAppPoolId: this.currentAppIdentityPoolId,\r\n        finalPoolId: finalRequest.identityPoolId\r\n      });\r\n      \r\n      // Log when using app's identity pool\r\n      if (!request.identityPoolId && this.currentAppIdentityPoolId) {\r\n        console.log('[ApiClient] Using app identity pool for request:', this.currentAppIdentityPoolId);\r\n      }\r\n\r\n      const fetchOptions: RequestInit = {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          \"x-app\": app,\r\n        },\r\n        body: JSON.stringify(finalRequest), // Use finalRequest which includes identityPoolId\r\n      };\r\n\r\n      // Add native fetch caching if requested\r\n      if (request.useCache) {\r\n        fetchOptions.cache = 'force-cache';\r\n      }\r\n\r\n      const response = await fetch(url, fetchOptions);\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `HTTP ${response.status}: ${response.statusText}`,\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      return data;\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : \"Unknown error\",\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiClient = new ApiClient();\r\n\r\n// Helper function for Cognito admin operations\r\nexport async function runCognitoAdminOperation<T = any>(\r\n  operation: string,\r\n  params?: any\r\n): Promise<CaptifyResponse<T>> {\r\n  // Get admin Identity Pool ID from environment or use hardcoded value\r\n  const adminPoolId = process.env.NEXT_PUBLIC_COGNITO_ADMIN_IDENTITY_POOL_ID || \r\n                      'us-east-1:52e865f2-4871-4a74-8976-edc945af0c0f';\r\n  \r\n  return apiClient.run<T>({\r\n    service: 'cognito',\r\n    operation,\r\n    app: 'core',\r\n    identityPoolId: adminPoolId,\r\n    forceRefresh: true, // Always refresh for admin operations\r\n    data: params,\r\n  });\r\n}\r\n","\"use client\";\r\n\r\nimport React from \"react\";\r\n\r\n// Ensure React is available in the global scope for monorepo compatibility\r\nif (typeof window !== \"undefined\" && !window.React) {\r\n  (window as any).React = React;\r\n}\r\n\r\n// Safe hook wrapper that prevents SSR errors\r\nexport function useSafeRef<T>(initialValue: T) {\r\n  if (typeof window === \"undefined\") {\r\n    // SSR: Return a simple object that acts like a ref\r\n    return { current: initialValue };\r\n  }\r\n  return React.useRef<T>(initialValue);\r\n}\r\n\r\nexport function useSafeState<T>(initialState: T | (() => T)) {\r\n  if (typeof window === \"undefined\") {\r\n    // SSR: Return initial state and a no-op setter\r\n    const initial =\r\n      typeof initialState === \"function\"\r\n        ? (initialState as () => T)()\r\n        : initialState;\r\n    return [initial, () => {}] as const;\r\n  }\r\n  return React.useState(initialState);\r\n}\r\n\r\nexport function useSafeEffect(\r\n  effect: React.EffectCallback,\r\n  deps?: React.DependencyList\r\n) {\r\n  if (typeof window === \"undefined\") {\r\n    // SSR: Do nothing\r\n    return;\r\n  }\r\n  return React.useEffect(effect, deps);\r\n}\r\n\r\n// Export safe hooks with standard names for easy replacement\r\nexport const useState = useSafeState;\r\nexport const useRef = useSafeRef;\r\nexport const useEffect = useSafeEffect;\r\n\r\nexport default React;\r\n","import NextAuth from \"next-auth\";\r\nimport type { NextAuthConfig } from \"next-auth\";\r\nimport CognitoProvider from \"next-auth/providers/cognito\";\r\n\r\n/**\r\n * Refresh the access token using the refresh token\r\n * @param refreshToken - The refresh token from Cognito\r\n * @returns The new tokens\r\n */\r\nasync function refreshAccessToken(refreshToken: string) {\r\n  try {\r\n    // Check if we have a refresh token\r\n    if (!refreshToken) {\r\n      // Log error without using console.error on server\r\n      if (typeof window !== \"undefined\") {\r\n        console.error(\"No refresh token available\");\r\n      }\r\n      throw new Error(\"No refresh token available\");\r\n    }\r\n\r\n    // Check if environment variables are set\r\n    if (\r\n      !process.env.COGNITO_ISSUER ||\r\n      !process.env.COGNITO_CLIENT_ID ||\r\n      !process.env.COGNITO_CLIENT_SECRET\r\n    ) {\r\n      // Server-side logging allowed here as this is configuration error\r\n      // But still check to avoid client-side errors\r\n      if (typeof window !== \"undefined\") {\r\n        console.error(\"Missing Cognito environment variables\");\r\n      }\r\n      throw new Error(\"Missing Cognito configuration\");\r\n    }\r\n\r\n    const url = `${process.env.COGNITO_ISSUER}/oauth2/token`;\r\n\r\n    // Debug logging only in development\r\n    if (\r\n      process.env.NODE_ENV === \"development\" &&\r\n      typeof window !== \"undefined\"\r\n    ) {\r\n      console.log(\"Attempting to refresh token at:\", url);\r\n    }\r\n\r\n    const response = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: new URLSearchParams({\r\n        grant_type: \"refresh_token\",\r\n        refresh_token: refreshToken,\r\n        client_id: process.env.COGNITO_CLIENT_ID!,\r\n        client_secret: process.env.COGNITO_CLIENT_SECRET!,\r\n      }),\r\n    });\r\n\r\n    const responseText = await response.text();\r\n\r\n    // Try to parse as JSON\r\n    let refreshedTokens;\r\n    try {\r\n      refreshedTokens = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      // Log error without using console.error on server\r\n      if (typeof window !== \"undefined\") {\r\n        console.error(\"Failed to parse refresh response:\", responseText);\r\n      }\r\n      throw new Error(`Invalid response from token endpoint: ${responseText}`);\r\n    }\r\n\r\n    if (!response.ok) {\r\n      // Log error without using console.error on server\r\n      if (typeof window !== \"undefined\") {\r\n        console.error(\"Token refresh failed:\", {\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          error: refreshedTokens.error,\r\n          error_description: refreshedTokens.error_description,\r\n        });\r\n      }\r\n      throw new Error(\r\n        refreshedTokens.error_description ||\r\n          refreshedTokens.error ||\r\n          \"Token refresh failed\"\r\n      );\r\n    }\r\n\r\n    // Validate the response has required fields\r\n    if (!refreshedTokens.access_token) {\r\n      // Log error without using console.error on server\r\n      if (typeof window !== \"undefined\") {\r\n        console.error(\"No access token in refresh response:\", refreshedTokens);\r\n      }\r\n      throw new Error(\"Invalid token refresh response - missing access_token\");\r\n    }\r\n\r\n    return {\r\n      access_token: refreshedTokens.access_token,\r\n      id_token: refreshedTokens.id_token,\r\n      expires_in: refreshedTokens.expires_in ?? 3600, // Default to 1 hour\r\n      refresh_token: refreshedTokens.refresh_token,\r\n    };\r\n  } catch (error) {\r\n    // Log error without using console.error on server\r\n    if (typeof window !== \"undefined\") {\r\n      console.error(\"Error refreshing access token:\", {\r\n        error: error instanceof Error ? error.message : error,\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nconst authConfig: NextAuthConfig = {\r\n  providers: [\r\n    CognitoProvider({\r\n      clientId: process.env.COGNITO_CLIENT_ID!,\r\n      clientSecret: process.env.COGNITO_CLIENT_SECRET!,\r\n      issuer: process.env.COGNITO_ISSUER,\r\n      checks: [\"pkce\", \"state\"], // no \"nonce\"\r\n      authorization: {\r\n        params: {\r\n          scope: \"openid email profile\",\r\n          response_type: \"code\",\r\n          response_mode: \"query\",\r\n        },\r\n      },\r\n      // Override the nonce check\r\n      profile(profile) {\r\n        return {\r\n          id: profile.sub,\r\n          name: profile.name,\r\n          email: profile.email,\r\n          image: profile.picture,\r\n        };\r\n      },\r\n    }),\r\n  ],\r\n  pages: {\r\n    signIn: \"/auth/signin\",\r\n    error: \"/auth/error\",\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, account, profile }) {\r\n      // Initial sign in\r\n      if (account && profile) {\r\n        // Debug logging only in development\r\n        if (process.env.NODE_ENV === \"development\") {\r\n          console.log(\"JWT Callback - Initial sign in\", { account, profile });\r\n        }\r\n        return {\r\n          ...token,\r\n          accessToken: account.access_token,\r\n          idToken: account.id_token,\r\n          refreshToken: account.refresh_token,\r\n          expiresAt: account.expires_at,\r\n          username: profile.preferred_username || profile.email,\r\n          groups: (profile as any)[\"cognito:groups\"] || [],\r\n        };\r\n      }\r\n\r\n      // Return previous token if the access token has not expired yet\r\n      // Check 5 minutes before expiry to ensure smooth refresh\r\n      const refreshBuffer = 5 * 60 * 1000; // 5 minutes in milliseconds\r\n      if (Date.now() < (token.expiresAt as number) * 1000 - refreshBuffer) {\r\n        return token;\r\n      }\r\n\r\n      // Access token has expired or is about to expire, refresh it\r\n      // Debug logging only in development\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.log(\"Token expired or expiring soon, refreshing...\");\r\n      }\r\n\r\n      // Check if we have a refresh token\r\n      if (!token.refreshToken) {\r\n        // Log error without using console.error on server\r\n        if (typeof window !== \"undefined\") {\r\n          console.error(\"No refresh token available in JWT token\");\r\n        }\r\n        return { ...token, error: \"RefreshAccessTokenError\" };\r\n      }\r\n\r\n      // Refresh the access token using the refresh token\r\n      try {\r\n        const refreshedTokens = await refreshAccessToken(\r\n          token.refreshToken as string\r\n        );\r\n\r\n        // Debug logging only in development\r\n        if (process.env.NODE_ENV === \"development\") {\r\n          console.log(\"Token refreshed successfully\");\r\n        }\r\n\r\n        return {\r\n          ...token,\r\n          accessToken: refreshedTokens.access_token,\r\n          idToken: refreshedTokens.id_token,\r\n          refreshToken: refreshedTokens.refresh_token || token.refreshToken, // Use new refresh token if provided\r\n          expiresAt: Math.floor(Date.now() / 1000) + refreshedTokens.expires_in,\r\n        };\r\n      } catch (error) {\r\n        // Log error without using console.error on server\r\n        if (typeof window !== \"undefined\") {\r\n          console.error(\"Failed to refresh access token:\", {\r\n            error: error instanceof Error ? error.message : error,\r\n            hasRefreshToken: !!token.refreshToken,\r\n            tokenExpiry: token.expiresAt\r\n              ? new Date((token.expiresAt as number) * 1000).toISOString()\r\n              : \"unknown\",\r\n          });\r\n        }\r\n        // Return the old token and let the session expire\r\n        // The user will be redirected to sign in\r\n        return { ...token, error: \"RefreshAccessTokenError\" };\r\n      }\r\n    },\r\n    async session({ session, token }) {\r\n      // Send properties to the client\r\n      // Debug logging only in development\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.log(\"Session Callback\", { token });\r\n      }\r\n\r\n      // Check for token refresh error\r\n      if ((token as any).error === \"RefreshAccessTokenError\") {\r\n        // Log error without using console.error on server\r\n        if (typeof window !== \"undefined\") {\r\n          console.error(\r\n            \"Session has a refresh error, user needs to re-authenticate\"\r\n          );\r\n        }\r\n        // Return a session with an error flag\r\n        return {\r\n          ...session,\r\n          error: \"RefreshAccessTokenError\",\r\n        };\r\n      }\r\n\r\n      session.user = {\r\n        ...session.user,\r\n        id: token.sub!,\r\n      };\r\n      (session as any).username = token.username;\r\n      (session as any).accessToken = token.accessToken;\r\n      (session as any).idToken = token.idToken;\r\n      (session as any).expiresAt = token.expiresAt;\r\n      (session as any).groups = token.groups || [];\r\n\r\n      // Set captifyStatus based on groups\r\n      const groups = (token.groups as string[]) || [];\r\n      if (groups.includes(\"Admins\") || groups.includes(\"Administrators\")) {\r\n        (session as any).captifyStatus = \"approved\";\r\n      } else {\r\n        (session as any).captifyStatus = \"pending\";\r\n      }\r\n\r\n      return session;\r\n    },\r\n    async redirect({ url, baseUrl }) {\r\n      // Handle redirect after sign in\r\n      // Debug logging only in development\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.log(\"Redirect callback\", { url, baseUrl });\r\n      }\r\n      // Always redirect to home after sign in\r\n      return baseUrl;\r\n    },\r\n  },\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 60 * 60, // 1 hour\r\n  },\r\n  cookies: {\r\n    pkceCodeVerifier: {\r\n      name: \"next-auth.pkce.code_verifier\",\r\n      options: {\r\n        httpOnly: true,\r\n        sameSite: \"lax\",\r\n        path: \"/\",\r\n        secure: process.env.NODE_ENV === \"production\",\r\n        maxAge: 900, // 15 minutes\r\n      },\r\n    },\r\n    state: {\r\n      name: \"next-auth.state\",\r\n      options: {\r\n        httpOnly: true,\r\n        sameSite: \"lax\",\r\n        path: \"/\",\r\n        secure: process.env.NODE_ENV === \"production\",\r\n        maxAge: 900, // 15 minutes\r\n      },\r\n    },\r\n    nonce: {\r\n      name: \"next-auth.nonce\",\r\n      options: {\r\n        httpOnly: true,\r\n        sameSite: \"lax\",\r\n        path: \"/\",\r\n        secure: process.env.NODE_ENV === \"production\",\r\n        maxAge: 900, // 15 minutes\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\nconst authResult = NextAuth(authConfig);\r\nexport const handlers = authResult.handlers;\r\nexport const auth = authResult.auth;\r\nexport const signIn: typeof authResult.signIn = authResult.signIn;\r\nexport const signOut = authResult.signOut;\r\n","import { clsx, type ClassValue } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\nimport type { Session } from \"next-auth\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\nexport function createApiClient(): CaptifyClient {\r\n  return new CaptifyClient({\r\n    appId: \"core\",\r\n    session: null, // Session will be handled by the client internally\r\n  });\r\n}\r\n\r\nexport interface CaptifyResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: string;\r\n}\r\n\r\nexport interface ApiRequest {\r\n  service: string;\r\n  operation: string;\r\n  app?: string;\r\n  table?: string;\r\n  data?: {\r\n    values?: Array<{ [field: string]: any }>;\r\n    fields?: string[];\r\n    index?: string;\r\n    limit?: number;\r\n    start?: any;\r\n    [key: string]: any; // Allow any additional data\r\n  };\r\n}\r\n\r\nclass ApiClient {\r\n  async run<T = any>(request: ApiRequest): Promise<CaptifyResponse<T>> {\r\n    try {\r\n      // Use app from request, default to \"core\" if not specified\r\n      const app = request.app || \"core\";\r\n      const url = `/api/captify`;\r\n\r\n      const response = await fetch(url, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          \"x-app\": app,\r\n        },\r\n        body: JSON.stringify(request),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `HTTP ${response.status}: ${response.statusText}`,\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      return data;\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : \"Unknown error\",\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiClient = new ApiClient();\r\n\r\n// CaptifyClient with convenience methods\r\nexport class CaptifyClient extends ApiClient {\r\n  private appId: string;\r\n  private session: Session | null;\r\n\r\n  constructor(config?: { appId?: string; session?: Session | null }) {\r\n    super();\r\n    this.appId = config?.appId || \"core\";\r\n    this.session = config?.session || null;\r\n  }\r\n\r\n  async query(params: { table: string; [key: string]: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"query\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: params,\r\n    });\r\n  }\r\n\r\n  async get(params: { table: string; [key: string]: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"scan\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: params,\r\n    });\r\n  }\r\n\r\n  async getItem(params: { table: string; key: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"get\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: { key: params.key },\r\n    });\r\n  }\r\n\r\n  async put(params: { table: string; data: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"put\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: params.data,\r\n    });\r\n  }\r\n\r\n  async update(params: { table: string; [key: string]: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"update\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: params,\r\n    });\r\n  }\r\n\r\n  async delete(params: { table: string; key: any }) {\r\n    return this.run({\r\n      service: \"dynamo\",\r\n      operation: \"delete\",\r\n      app: this.appId,\r\n      table: params.table,\r\n      data: { key: params.key },\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","names":["ApiClient","apiClient"]}